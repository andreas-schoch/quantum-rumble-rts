/*! For license information please see simulation.worker.e2c03278792b6b8cb245.bundle.worker.js.LICENSE.txt */
(()=>{"use strict";const e=Symbol("Comlink.proxy"),t=Symbol("Comlink.endpoint"),n=Symbol("Comlink.releaseProxy"),o=Symbol("Comlink.finalizer"),r=Symbol("Comlink.thrown"),s=e=>"object"==typeof e&&null!==e||"function"==typeof e,a=new Map([["proxy",{canHandle:t=>s(t)&&t[e],serialize(e){const{port1:t,port2:n}=new MessageChannel;return i(e,t),[n,[n]]},deserialize:e=>(e.start(),d(e,[],undefined))}],["throw",{canHandle:e=>s(e)&&r in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function i(t,n=globalThis,s=["*"]){n.addEventListener("message",(function a(l){if(!l||!l.data)return;if(!function(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(s,l.origin))return void console.warn(`Invalid origin '${l.origin}' for comlink proxy`);const{id:f,type:u,path:h}=Object.assign({path:[]},l.data),d=(l.data.argumentList||[]).map(m);let g;try{const n=h.slice(0,-1).reduce(((e,t)=>e[t]),t),o=h.reduce(((e,t)=>e[t]),t);switch(u){case"GET":g=o;break;case"SET":n[h.slice(-1)[0]]=m(l.data.value),g=!0;break;case"APPLY":g=o.apply(n,d);break;case"CONSTRUCT":g=function(t){return Object.assign(t,{[e]:!0})}(new o(...d));break;case"ENDPOINT":{const{port1:e,port2:n}=new MessageChannel;i(t,n),g=function(e,t){return y.set(e,t),e}(e,[e])}break;case"RELEASE":g=void 0;break;default:return}}catch(e){g={value:e,[r]:0}}Promise.resolve(g).catch((e=>({value:e,[r]:0}))).then((e=>{const[r,s]=p(e);n.postMessage(Object.assign(Object.assign({},r),{id:f}),s),"RELEASE"===u&&(n.removeEventListener("message",a),c(n),o in t&&"function"==typeof t[o]&&t[o]())})).catch((e=>{const[t,o]=p({value:new TypeError("Unserializable return value"),[r]:0});n.postMessage(Object.assign(Object.assign({},t),{id:f}),o)}))})),n.start&&n.start()}function c(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function l(e){if(e)throw new Error("Proxy has been released and is not useable")}function f(e){return w(e,{type:"RELEASE"}).then((()=>{c(e)}))}const u=new WeakMap,h="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(u.get(e)||0)-1;u.set(e,t),0===t&&f(e)}));function d(e,o=[],r=function(){}){let s=!1;const a=new Proxy(r,{get(t,r){if(l(s),r===n)return()=>{!function(e){h&&h.unregister(e)}(a),f(e),s=!0};if("then"===r){if(0===o.length)return{then:()=>a};const t=w(e,{type:"GET",path:o.map((e=>e.toString()))}).then(m);return t.then.bind(t)}return d(e,[...o,r])},set(t,n,r){l(s);const[a,i]=p(r);return w(e,{type:"SET",path:[...o,n].map((e=>e.toString())),value:a},i).then(m)},apply(n,r,a){l(s);const i=o[o.length-1];if(i===t)return w(e,{type:"ENDPOINT"}).then(m);if("bind"===i)return d(e,o.slice(0,-1));const[c,f]=g(a);return w(e,{type:"APPLY",path:o.map((e=>e.toString())),argumentList:c},f).then(m)},construct(t,n){l(s);const[r,a]=g(n);return w(e,{type:"CONSTRUCT",path:o.map((e=>e.toString())),argumentList:r},a).then(m)}});return function(e,t){const n=(u.get(t)||0)+1;u.set(t,n),h&&h.register(e,t,e)}(a,e),a}function g(e){const t=e.map(p);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const y=new WeakMap;function p(e){for(const[t,n]of a)if(n.canHandle(e)){const[o,r]=n.serialize(e);return[{type:"HANDLER",name:t,value:o},r]}return[{type:"RAW",value:e},y.get(e)||[]]}function m(e){switch(e.type){case"HANDLER":return a.get(e.name).deserialize(e.value);case"RAW":return e.value}}function w(e,t,n){return new Promise((o=>{const r=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===r&&(e.removeEventListener("message",t),o(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:r},t),n)}))}const E=.5*(Math.sqrt(3)-1),b=(3-Math.sqrt(3))/6,v=(Math.sqrt(5),Math.sqrt(5),e=>0|Math.floor(e)),C=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);const M={elevationMax:12e3},A={overflow:2e3,flowRate:.4,evaporation:10},x={seed:.123,sizeX:100,sizeY:100,cityCoords:{x:50,y:27},noise:[{scale:200,offsetX:0,offsetY:0,strength:2.5},{scale:96,offsetX:0,offsetY:0,strength:2},{scale:32,offsetX:0,offsetY:0,strength:1},{scale:32,offsetX:-150,offsetY:-150,strength:2,subtract:!0}],rects:[{x:75,y:25,w:4,h:4,elevation:3e3},{x:75,y:25,w:2,h:2,elevation:0}],emitters:[{xCoord:19,yCoord:36,fluidPerSecond:131070,ticksCooldown:1,ticksDelay:0},{xCoord:10,yCoord:75,fluidPerSecond:131070,ticksCooldown:1,ticksDelay:0},{xCoord:78,yCoord:54,fluidPerSecond:131070,ticksCooldown:1,ticksDelay:0}]},z=(x.sizeX+1)*(x.sizeY+1)*Uint16Array.BYTES_PER_ELEMENT,S=new SharedArrayBuffer(z),k=new SharedArrayBuffer(z),R=new SharedArrayBuffer(z),X=new SharedArrayBuffer(z),P=new Uint16Array(S),T=new Uint16Array(k),L=new Uint16Array(R),N=new Uint16Array(X);i(new class{constructor(){this.flowNeighbours=[[1,0],[-1,0],[0,1],[0,-1]],this.cellEdges=[[0,0],[1,0],[1,1],[0,1]],this.fluidChangeRequests=[],this.noise=function(e=Math.random){const t=function(e){const t=new Uint8Array(512);for(let e=0;e<256;e++)t[e]=e;for(let n=0;n<255;n++){const o=n+~~(e()*(256-n)),r=t[n];t[n]=t[o],t[o]=r}for(let e=256;e<512;e++)t[e]=t[e-256];return t}(e),n=new Float64Array(t).map((e=>C[e%12*2])),o=new Float64Array(t).map((e=>C[e%12*2+1]));return function(e,r){let s=0,a=0,i=0;const c=(e+r)*E,l=v(e+c),f=v(r+c),u=(l+f)*b,h=e-(l-u),d=r-(f-u);let g,y;h>d?(g=1,y=0):(g=0,y=1);const p=h-g+b,m=d-y+b,w=h-1+2*b,C=d-1+2*b,M=255&l,A=255&f;let x=.5-h*h-d*d;if(x>=0){const e=M+t[A];x*=x,s=x*x*(n[e]*h+o[e]*d)}let z=.5-p*p-m*m;if(z>=0){const e=M+g+t[A+y];z*=z,a=z*z*(n[e]*p+o[e]*m)}let S=.5-w*w-C*C;if(S>=0){const e=M+1+t[A+1];S*=S,i=S*S*(n[e]*w+o[e]*C)}return 70*(s+a+i)}}((()=>x.seed)),this.collectors=new Map;const{elevationMax:e}=M;console.log("simulation init");const t=x.noise.filter((e=>!e.subtract)).length;for(let n=0;n<=x.sizeY;n++)for(let o=0;o<=x.sizeX;o++){let r=0,s=0;for(const{scale:t,strength:a,subtract:i,offsetX:c,offsetY:l}of x.noise){const f=Math.max(this.noise((o-c)/t,(n-l)/t)*e*a,0);i?s+=f:r+=f}r-=s,r=Math.min(Math.max(r/t,0),e),r<2500&&(r=0),r=3e3*Math.floor(r/3e3);const a=n*(x.sizeX+1)+o;L[a]=r}for(const e of x.rects)for(let t=e.y;t<e.y+e.h;t++)for(let n=e.x;n<e.x+e.w;n++){const o=t*(x.sizeX+1)+n;L[o]=e.elevation}}getData(){return{terrainData:L,fluidData:T,collectionData:N}}collectionChangeRequest(e,t,n,o){this.collectors.set(o,{id:o,xCoord:e,yCoord:t,radius:n}),N.fill(0);for(const{xCoord:e,yCoord:t,radius:n}of this.collectors.values())for(let o=-n;o<=n;o++)for(let r=-n;r<=n;r++)if(Math.sqrt(r*r+o*o)<=n){const n=(t+o)*(x.sizeX+1)+(e+r);N[n]=1}}fluidChangeRequest(e,t,n,o=[[0,0]]){const r=n/(4*o.length);for(const[n,s]of o)for(const[o,a]of this.cellEdges)this.fluidChangeRequests.push({xCoord:e+n+o,yCoord:t+s+a,amount:r})}tick(e){const{flowRate:t,overflow:n}=A,{elevationMax:o}=M;for(const{xCoord:e,yCoord:t,amount:r}of this.fluidChangeRequests){const s=t*(x.sizeX+1)+e;T[s]=Math.min(Math.max(T[s]+r,0),o+n)}this.fluidChangeRequests.length=0,P.set(T);const r=P.reduce(((e,t)=>e+t),0),s=Array.from({length:this.flowNeighbours.length},(()=>[0,0]));let a=0;for(let e=0;e<=x.sizeY;e++)for(let n=0;n<=x.sizeX;n++){const o=e*(x.sizeX+1)+n,r=P[o],i=r+L[o];if(r<500&&(P[o]=0),r<900)continue;a=0;for(const[t,o]of this.flowNeighbours){const r=n+t,c=e+o,l=s[a++];if(!(r>=0&&r<=x.sizeX&&c>=0&&c<=x.sizeY)){l[0]=-1,l[1]=-1;continue}const f=c*(x.sizeX+1)+r,u=i-(P[f]+L[f]);l[0]=u,l[1]=f}s.sort(((e,t)=>t[0]-e[0]));const c=t/this.flowNeighbours.length;for(const[e,t]of s){if(e<2||-1===t)continue;const n=e*c,r=T[o]*c,s=Math.floor(Math.min(Math.max(n,0),r));if(s<1)break;T[o]-=s,T[t]+=s}}const i=T.reduce(((e,t)=>e+t),0);console.assert(r===i,"loss of density due to adding or subtracting fractions to uint16array")}})})();